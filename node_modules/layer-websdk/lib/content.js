"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/**
 * The Content class represents External Content.
 *
 * Note that instances of this class will automatically be
 * generated for developers based on whether their message parts
 * require it.
 *
 * That means for the most part, you should never need to
 * instantiate one of these directly.
 *
 *      var content = new layer.Content({
 *          id: 'layer:///content/8c839735-5f95-439a-a867-30903c0133f2'
 *      });
 *
 * @class  layer.Content
 * @protected
 * @extends layer.Root
 * @author Michael Kantor
 */

var Root = require("./root");
var xhr = require("./xhr");

var Content = (function (_Root) {

  /**
   * Constructor
   *
   * @method constructor
   * @param  {Object} options
   * @param  {string} options.id - Identifier for the content
   * @param  {string} [options.downloadUrl=null] - Url to download the content from
   * @param  {Date} [options.expiration] - Expiration date for the url
   * @param  {string} [options.refreshUrl] - Url to access to get a new downloadUrl after it has expired
   *
   * @return {layer.Content}
   */

  function Content(options) {
    _classCallCheck(this, Content);

    if (typeof options === "string") {
      options = { id: options };
    }
    _get(Object.getPrototypeOf(Content.prototype), "constructor", this).call(this, options);
  }

  _inherits(Content, _Root);

  _createClass(Content, {
    loadContent: {

      /**
       * Loads the data from google's cloud storage.
       *
       * Data is provided via callback.
       *
       * Note that typically one should use MessagePart.loadContent() rather than Content.loadContent()
       *
       * TODO: A 400 response means the content has expired; have yet to validate that we need to test for this.
       *
       * @method loadContent
       * @param {string} mimeType - Mime type for the Blob
       * @param {Function} callback
       * @param {Blob} callback.data - A Blob instance representing the data downloaded.  If Blob object is not available, then may use other format.
       */

      value: function loadContent(mimeType, callback) {
        xhr({
          url: this.downloadUrl,
          responseType: "arraybuffer" }, function (result) {
          if (typeof Blob !== "undefined") {
            var blob = new Blob([result.data], { type: mimeType });
            callback(blob);
          } else {
            // If the blob class isn't defined (nodejs) then just return the result as is
            callback(result.data);
          }
        });
      }
    },
    refreshContent: {

      /**
       * Refreshes the URL, which updates the URL and resets the expiration time for the URL
       *
       * @method refreshContent
       * @param {layer.Client} client
       * @param {Function} [callback]
       */

      value: function refreshContent(client, callback) {
        var _this = this;

        client.xhr({
          url: this.refreshUrl,
          method: "GET" }, function (result) {
          var data = result.data;

          _this.expiration = data.expiration;
          _this.downloadUrl = data.download_url;
          if (callback) callback(_this.downloadUrl);
        });
      }
    },
    isExpired: {

      /**
       * Is the download url expired or about to expire?
       * We can't be sure of the state of the device's internal clock,
       * so if its within 10 minutes of expiring, just treat it as expired.
       *
       * TODO: I would like a better solution to this.
       *
       * @method isExpired
       * @returns {Boolean}
       */

      value: function isExpired() {
        var expirationLeeway = 10 * 60 * 1000;
        return this.expiration.getTime() - expirationLeeway < Date.now();
      }
    }
  }, {
    _createFromServer: {

      /**
       * Creates a MessagePart from a server representation of the part
       *
       * @method _createFromServer
       * @private
       * @static
       * @param  {Object} part - Server representation of a part
       */

      value: function _createFromServer(part) {
        return new Content({
          id: part.id,
          downloadUrl: part.download_url,
          expiration: new Date(part.expiration),
          refreshUrl: part.refresh_url });
      }
    }
  });

  return Content;
})(Root);

/**
 * Server generated identifier
 * @type {string}
 */
Content.prototype.id = "";

Content.prototype.blob = null;

/**
 * Server generated url for downloading the content
 * @type {string}
 */
Content.prototype.downloadUrl = "";

/**
 * Url for refreshing the downloadUrl after it has expired
 * @type {string}
 */
Content.prototype.refreshUrl = "";

/**
 * Size of the content.
 *
 * This property only has a value when in the process
 * of Creating the external content and sending the Message.
 *
 * @type {number}
 */
Content.prototype.size = 0;

/**
 * Expiration date for the downloadUrl
 * @type {Date}
 */
Content.prototype.expiration = null;

Root.initClass.apply(Content, [Content, "Content"]);
module.exports = Content;