"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/**
 * The Message Class represents messages sent amongst participants
 * of of a Conversation.
 *
 * The simplest way to create and send a message is:
 *
 *      var m = conversation.createMessage('Hello there').send();
 *
 * Typically, rendering would be done as follows:
 *
 *      // Create a layer.Query that loads Messages for the
 *      // specified Conversation.
 *      var query = new layer.Query({
 *        model: Query.Message,
 *        predicate: 'conversation = "' + conversation.id + '"'
 *      });
 *
 *      // Any time the Query's data changes the 'change'
 *      // event will fire.
 *      query.on('change', function(layerEvt) {
 *        if (layerEvt.type == 'insert') {
 *          renderNewMessages(layerEvt.data);
 *        }
 *      });
 *
 *      // This will cause the above event handler to receive
 *      // a change event where `type` = 'insert'.
 *      conversation.createMessage('Hello there').send();
 *
 * The above code will trigger the following events:
 *
 *  * Message Instance fires
 *    * messages:sending: An event that lets you modify the message prior to sending
 *    * messages:sent: The message was received by the server
 *  * Query Instance fires
 *    * change: The query has received a new Message
 *
 * When creating a Message there are a number of ways to structure it.
 * All of these are valid; all of them are just shorthand for
 * accomplishing this:
 *
 *      var m = conversation.createMessage({
 *          parts: [new layer.MessagePart({
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          })]
 *      });
 *
 *      // Option 1: Pass in Objects instead of layer.MessageParts
 *      var m = conversation.createMessage({
 *          parts: new layer.MessagePart({
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          })
 *      });
 *
 *      // Option 2: Pass in a string (automatically assumes mimeType is text/plain)
 *      // instead of an array of objects.
 *      var m = conversation.createMessage({
 *          parts: 'Hello'
 *      });
 *
 *      // Option 3: Pass in an array of strings (automatically assumes mimeType is text/plain)
 *      var m = conversation.createMessage({
 *          parts: ['Hello']
 *      });
 *
 *      // Option 4: Pass in just a string and nothing else
 *      var m = conversation.createMessage('Hello');
 *
 *      // Option 5:
 *      var m = converseation.createMessage();
 *      m.addPart({body: "hello", mimeType: "text/plain"});
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * `id`: this property is worth being familiar with; it identifies the
 *   Message and can be used in `client.getMessage(id)` to retrieve it
 *   at any time.
 * * `internalId`: This property makes for a handy unique ID for use in dom nodes.
 *   It is gaurenteed not to change during this session.
 * * `isRead`: Indicates if the Message has been read yet; set `m.isRead = true`
 *   to tell the client and server that the message has been read.
 * * `parts`: An array of layer.MessagePart classes representing the contents of the Message.
 * * `sentAt`: Date the message was sent
 * * `sender.userId`: Conversation participant who sent the Message. You may
 *   need to do a lookup on this id in your own servers to find a
 *   displayable name for it.
 *
 * Methods:
 *
 * * `send()`: Sends the message to the server and the other participants.
 * * `on()` and `off()`; event listeners built on top of the `backbone-events-standalone` npm project
 *
 * Events:
 *
 * * `messages:sent`: The message has been received by the server. Can also subscribe to
 *   this event from the layer.Client which is usually simpler.
 *
 * @class  layer.Message
 * @extends layer.Syncable
 */

var Root = require("./root");
var Syncable = require("./syncable");
var MessagePart = require("./message-part");
var LayerError = require("./layer-error");
var Constants = require("./const");
var Util = require("./client-utils");
var ClientRegistry = require("./client-registry");

var Message = (function (_Syncable) {
  /**
   * See Conversation.createMessage()
   *
   * @method constructor
   * @return {layer.Message}
   */

  function Message() {
    var options = arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Message);

    // Unless this is a server representation, this is a developer's shorthand;
    // fill in the missing properties around isRead/isUnread before initializing.
    if (!options.fromServer) {
      if ("isUnread" in options) {
        options.isRead = !options.isUnread && !options.is_unread;
      } else {
        options.isRead = true;
      }
    } else {
      options.id = options.fromServer.id;
    }

    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error("clientId property required to create a Message");
    if (options.conversation) options.conversationId = options.conversation.id;

    // Insure __adjustParts is set AFTER clientId is set.
    var parts = options.parts;
    options.parts = null;

    _get(Object.getPrototypeOf(Message.prototype), "constructor", this).call(this, options);
    this.parts = parts;

    var client = this.getClient();
    this.isInitializing = true;
    if (options && options.fromServer) {
      this._populateFromServer(options.fromServer);
    } else {
      this.sender = { userId: "", name: "" };
      this.sentAt = new Date();
    }

    if (!this.parts) this.parts = [];
    this.localCreatedAt = new Date();

    this._disableEvents = true;
    if (!this.recipientStatus) this.recipientStatus = {};else this.__updateRecipientStatus(this.recipientStatus);
    this._disableEvents = false;

    this.isInitializing = false;
    if (options && options.fromServer) {
      client._addMessage(this);
    }
  }

  _inherits(Message, _Syncable);

  _createClass(Message, {
    getClient: {

      /**
       * Get the Client associated with this layer.Message.
       *
       * Uses the clientId property.
       *
       * @method getClient
       * @return {layer.Client}
       */

      value: function getClient() {
        return ClientRegistry.get(this.clientId);
      }
    },
    getConversation: {

      /**
       * Get the Conversation associated with this layer.Message.
       *
       * Uses the conversationId.
       *
       * @method getConversation
       * @return {layer.Conversation}
       */

      value: function getConversation() {
        if (this.conversationId) {
          return ClientRegistry.get(this.clientId).getConversation(this.conversationId);
        }
      }
    },
    __adjustParts: {

      /**
       * Turn input into valid layer.MessageParts.
       *
       * This method is automatically called any time the parts
       * property is set (including during intialization).  This
       * is where we convert strings into MessageParts, and instances
       * into arrays.
       *
       * @method __adjustParts
       * @private
       * @param  {Mixed} parts -- Could be a string, array, object or MessagePart instance
       * @return {layer.MessagePart[]}
       */

      value: function __adjustParts(parts) {
        var _this = this;

        if (typeof parts === "string") {
          return [new MessagePart({
            body: parts,
            mimeType: "text/plain",
            clientId: this.clientId })];
        } else if (Array.isArray(parts)) {
          return parts.map(function (part) {
            var result = undefined;
            if (part instanceof MessagePart) {
              result = part;
            } else {
              result = new MessagePart(part);
            }
            result.clientId = _this.clientId;
            return result;
          });
        } else if (parts && typeof parts === "object") {
          parts.clientId = this.clientId;
          return [new MessagePart(parts)];
        }
      }
    },
    addPart: {

      /**
       * Add a MessagePart to this Message.
       *
       * Should only be done on an unsent Message.
       *
       * @method addPart
       * @param  {layer.MessagePart/Object} part - A layer.MessagePart instance or a {mimeType: 'text/plain', body: 'Hello'} formatted Object.
       */

      value: function addPart(part) {
        if (part) {
          part.clientId = this.clientId;
          if (typeof part === "object") {
            this.parts.push(new MessagePart(part));
          } else if (part instanceof MessagePart) {
            this.parts.push(part);
          }
        }
        return this;
      }
    },
    __updateRecipientStatus: {

      /**
       * Handle changes to the recipientStatus property.
       *
       * Any time the recipientStatus property is set,
       * Recalculate all of the recipient related properties:
       *
       * 1. isRead
       * 2. readStatus
       * 3. deliveryStatus
       *
       * @method __updateRecipientStatus
       * @private
       * @param  {Object} status - Object describing the delivered/read/sent value for each participant
       *
       */

      value: function __updateRecipientStatus(status, oldStatus) {
        var conversation = this.getConversation();
        var client = this.getClient();

        if (!conversation || Util.doesObjectMatch(status, oldStatus)) {
          return;
        }var userId = client.userId;
        var isSender = this.sender.userId === userId;
        var userHasRead = status[userId] === Constants.RECEIPT_STATE.READ;

        try {
          // -1 so we don't count this user
          var userCount = conversation.participants.length - 1;

          // If sent by this user or read by this user, update isRead/unread
          if (!this.__isRead && (isSender || userHasRead)) {
            this.__isRead = true; // no __updateIsRead event fired
          }

          // Update the readStatus/deliveryStatus properties

          var _getReceiptStatus = this._getReceiptStatus(status, userId);

          var readCount = _getReceiptStatus.readCount;
          var deliveredCount = _getReceiptStatus.deliveredCount;

          this._setReceiptStatus(readCount, deliveredCount, userCount);
        } catch (error) {}

        // Only trigger an event
        // 1. we're not initializing a new Message
        // 2. the user's state has been updated to read; we don't care about updates from other users if we aren't the sender.
        //    We also don't care about state changes to delivered; these do not inform rendering as the fact we are processing it
        //    proves its delivered.
        // 3. The user is the sender; in that case we do care about rendering receipts from other users
        if (!this.isInitializing && oldStatus) {
          var usersStateUpdatedToRead = userHasRead && oldStatus[userId] !== Constants.RECEIPT_STATE.READ;
          if (usersStateUpdatedToRead || isSender) {
            this._triggerAsync("messages:change", {
              oldValue: oldStatus,
              newValue: status,
              property: "recipientStatus" });
          }
        }
      }
    },
    _getReceiptStatus: {

      /**
       * Get the number of participants who have read and been delivered
       * this Message
       *
       * @method _getReceiptStatus
       * @private
       * @param  {Object} status
       * @param  {string} userId
       * @return {Object} result
       * @returns {number} result.readCount
       * @returns {number} result.deliveredCount
       */

      value: function _getReceiptStatus(status, userId) {
        var readCount = 0,
            deliveredCount = 0;
        var participant = undefined;
        for (participant in status) {
          if (participant !== userId && status.hasOwnProperty(participant)) {
            if (status[participant] === Constants.RECEIPT_STATE.READ) {
              readCount++;
              deliveredCount++;
            } else if (status[participant] === Constants.RECEIPT_STATE.DELIVERED) {
              deliveredCount++;
            }
          }
        }
        return {
          readCount: readCount,
          deliveredCount: deliveredCount };
      }
    },
    _setReceiptStatus: {

      /**
       * Sets the readStatus and deliveryStatus properties
       *
       * @method _setReceiptStatus
       * @private
       * @param  {number} readCount
       * @param  {number} deliveredCount
       * @param  {number} userCount
       */

      value: function _setReceiptStatus(readCount, deliveredCount, userCount) {
        if (readCount === userCount) {
          this.readStatus = Constants.RECIPIENT_STATE.ALL;
        } else if (readCount > 0) {
          this.readStatus = Constants.RECIPIENT_STATE.SOME;
        } else {
          this.readStatus = Constants.RECIPIENT_STATE.NONE;
        }
        if (deliveredCount === userCount) {
          this.deliveryStatus = Constants.RECIPIENT_STATE.ALL;
        } else if (deliveredCount > 0) {
          this.deliveryStatus = Constants.RECIPIENT_STATE.SOME;
        } else {
          this.deliveryStatus = Constants.RECIPIENT_STATE.NONE;
        }
      }
    },
    __updateIsRead: {

      /**
       * Handle changes to the isRead property.
       *
       * If someone called m.isRead = true, AND
       * if it was previously false, AND
       * if the call didn't come from updateRecipientStatus,
       * Then notify the server that the message has been read.
       *
       *
       * @method __updateIsRead
       * @private
       * @param  {boolean} value - True if isRead is true.
       */

      value: function __updateIsRead(value) {
        if (value) {
          this._sendReceipt(Constants.RECEIPT_STATE.READ);
          this._triggerAsync("messages:read");
          var conversation = this.getConversation();
          if (conversation) conversation.unreadCount--;
        }
      }
    },
    sendReceipt: {

      /**
       * Send a Read or Delivery Receipt to the server.
       *
       * @method sendReceipt
       * @param {string} [type=read] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
       * @return {layer.Message} this
       */

      value: function sendReceipt() {
        var type = arguments[0] === undefined ? Constants.RECEIPT_STATE.READ : arguments[0];

        if (type === Constants.RECEIPT_STATE.READ) {
          if (this.isRead) {
            return this;
          } else {
            // Without triggering the event, clearObject isn't called,
            // which means those using the toObject() data will have an isRead that doesn't match
            // this instance.  Which typically leads to lots of extra attempts
            // to mark the message as read.
            this.__isRead = true;
            this._triggerAsync("messages:read");
            var conversation = this.getConversation();
            if (conversation) conversation.unreadCount--;
          }
        }
        this._sendReceipt(type);
        return this;
      }
    },
    _sendReceipt: {

      /**
       * Send a Read or Delivery Receipt to the server.
       *
       * This bypasses any validation and goes direct to sending to the server.
       *
       * NOTE: Server errors are not handled; the local receipt state is suitable even
       * if out of sync with the server.
       *
       * @method _sendReceipt
       * @private
       * @param {string} [type=read] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
       */

      value: function _sendReceipt(type) {
        var _this = this;

        if (this.getConversation().participants.length === 0) {
          return;
        }this._setSyncing();
        this._xhr({
          url: "/receipts",
          method: "POST",
          data: {
            type: type },
          sync: {
            // This should not be treated as a POST/CREATE request on the Message
            operation: "RECEIPT" } }, function () {
          return _this._setSynced();
        });
      }
    },
    send: {

      /**
       * Send the message to all participants of the conversation.
       *
       * Message must have parts and a valid conversation to send successfully.
       *
       * @alias save
       * @method send
       * @param {Object} [notification] - Parameters for controling how the message is notificationed to phones,
       *                          and how phones notifications will occur.  See IOS and Android docs for details.
       * @param {string} [notification.text] - Text of your notification
       * @param {string} [notification.sound] - Name of an audio file or other sound-related hint
       * @return {layer.Message} this
       */

      value: function send(notification) {
        var client = this.getClient();
        var conversation = this.getConversation();

        if (this.syncState !== Constants.SYNC_STATE.NEW) {
          throw new Error(LayerError.dictionary.alreadySent);
        }
        if (!conversation) {
          throw new Error(LayerError.dictionary.conversationMissing);
        }

        if (!this.parts || !this.parts.length) {
          throw new Error(LayerError.dictionary.partsMissing);
        }

        this.sender.userId = client.userId;
        this.isSending = true;
        client._addMessage(this);

        // Make sure that the Conversation has been created on the server
        // and update the lastMessage property
        conversation.send(this);

        // allow for modification of message before sending
        this.trigger("messages:sending");

        var data = {
          parts: new Array(this.parts.length) };
        if (notification) data.notification = notification;

        this._preparePartsForSending(data);
        return this;
      }
    },
    _preparePartsForSending: {

      /**
       * Insures that each part is ready to send before actually sending the Message.
       *
       * @method _preparePartsForSending
       * @private
       * @param  {Object} structure to be sent to the server
       */

      value: function _preparePartsForSending(data) {
        var _this = this;

        var client = this.getClient();
        var count = 0;
        this.parts.forEach(function (part, index) {
          part.on("parts:send", function (evt) {
            data.parts[index] = {
              mime_type: evt.mime_type };
            if (evt.content) data.parts[index].content = evt.content;
            if (evt.body) data.parts[index].body = evt.body;
            if (evt.encoding) data.parts[index].encoding = evt.encoding;

            count++;
            if (count === _this.parts.length) {
              _this._send(data);
            }
          }, _this);
          part._send(client);
        });
      }
    },
    _send: {

      /**
       * Handle the actual sending.
       *
       * Message.send has some potentially asynchronous
       * preprocessing to do before sending; actual sending
       * is done here.
       *
       * @method _send
       * @private
       */

      value: function _send(data) {
        var _this = this;

        var client = this.getClient();
        var conversation = this.getConversation();

        this.sentAt = new Date();
        this._setSyncing();
        client.sendSocketRequest({
          method: "POST",
          body: function () {
            return {
              method: "Message.create",
              object_id: conversation.id,
              data: data };
          },
          sync: {
            depends: [this.conversationId, this.id],
            target: this.id } }, function (success, socketData) {
          return _this._sendResult(success, socketData);
        });
      }
    },
    _sendResult: {

      /**
        * Message.send() Success Callback
        *
        * If successfully sending the message; triggers a 'sent' event,
        * and updates the message.id/url
        *
        * @method _sendResult
        * @private
        * @param {Object} messageData - Server description of the message
        */

      value: function _sendResult(_ref) {
        var success = _ref.success;
        var data = _ref.data;

        if (this.isDestroyed) {
          return;
        }if (success) {
          var id = this.id;
          var client = this.getClient();
          this._populateFromServer(data);

          client._updateMessageId(this, id);
          this._triggerAsync("messages:sent");
          this._triggerAsync("messages:change", {
            oldValue: id,
            newValue: this.id,
            property: "id" });
        } else {
          this.trigger("messages:sent-error", { error: data });
          this.destroy();
        }
        this._setSynced();
      }
    },
    on: {

      /**
         * Standard `on()` provided by layer.Root.
         *
         * Adds some special handling of 'messages:loaded' so that calls such as
         *
         *      var m = client.getMessage('layer:///messages/123', true)
         *      .on('messages:loaded', function() {
         *          myrerender(m);
         *      });
         *      myrender(m); // render a placeholder for m until the details of m have loaded
         *
         * can fire their callback regardless of whether the client loads or has
         * already loaded the Message.
         *
         * @method on
         * @param  {string} eventName
         * @param  {Function} eventHandler
         * @param  {Object} context
         * @return {layer.Message} this
         */

      value: function on(name, callback, context) {
        var hasLoadedEvt = name === "messages:loaded" || name && typeof name === "object" && name["messages:loaded"];

        if (hasLoadedEvt && !this.isLoading) {
          (function () {
            var callNow = name === "messages:loaded" ? callback : name["messages:loaded"];
            Util.defer(function () {
              return callNow.apply(context);
            });
          })();
        }
        _get(Object.getPrototypeOf(Message.prototype), "on", this).call(this, name, callback, context);
        return this;
      }
    },
    "delete": {

      /**
       * Delete the message from the server.
       *
       * This destroys the local copy immediately, and attempts to also
       * delete the server's copy.
       *
       * @method delete
       * @param {boolean} destroy - if true, delete for all users, else just for this user.  False is not yet supported by the server.
       */

      value: function _delete(destroy) {
        var _this = this;

        if (this.isDestroyed) {
          throw new Error(LayerError.dictionary.isDestroyed);
        }

        if (this.syncState !== Constants.SYNC_STATE.NEW) {
          (function () {
            var id = _this.id;
            var client = _this.getClient();
            _this._xhr({
              url: "?destroy=" + Boolean(destroy),
              method: "DELETE" }, function (result) {
              if (!result.success) Message.load(id, client);
            });
          })();
        }

        this._deleted();
        this.destroy();

        return this;
      }
    },
    _deleted: {

      /**
       * The Message has been deleted.
       *
       * Called from WebsocketManager and from message.delete();
       * Put all code for cleaning up here... destroy is called separately.
       *
       * @method _deleted
       * @protected
       */

      value: function _deleted() {
        this.trigger("messages:delete");
      }
    },
    destroy: {

      /**
       * Remove this Message from the system.
       *
       * This will deregister the Message, remove all events
       * and allow garbage collection.
       *
       * @method destroy
       */

      value: function destroy() {
        this.getClient()._removeMessage(this);
        this.parts.forEach(function (part) {
          return part.destroy();
        });
        this.__parts = null;

        _get(Object.getPrototypeOf(Message.prototype), "destroy", this).call(this);
      }
    },
    _populateFromServer: {

      /**
       * Populates this instance with the description from the server.
       *
       * @method _populateFromServer
       * @protected
       * @param  {Object} m - Server description of the message
       */

      value: function _populateFromServer(message) {
        var _this = this;

        this.id = message.id;
        this.url = message.url;
        this.position = message.position;

        this.parts = message.parts.map(function (part) {
          var existingPart = _this.getPartById(part.id);
          if (existingPart) {
            existingPart._populateFromServer(part);
            return existingPart;
          } else {
            return MessagePart._createFromServer(part);
          }
        });

        this.recipientStatus = message.recipient_status || {};

        this.isRead = !message.is_unread;

        this.sentAt = new Date(message.sent_at);
        this.receivedAt = message.received_at ? new Date(message.received_at) : undefined;

        this.sender = {
          userId: message.sender.user_id || "",
          name: message.sender.name || "" };

        this._setSynced();
      }
    },
    getPartById: {

      /**
       * Returns the Message's part given the part's ID
       *
       * @method getPartById
       * @param {string} partId
       * @return {layer.MessagePart}
       */

      value: function getPartById(partId) {
        return this.parts ? this.parts.filter(function (part) {
          return part.id === partId;
        })[0] : null;
      }
    },
    _handlePatchEvent: {

      /**
       * Accepts json-patch operations for modifying recipientStatus.
       *
       * @method _handlePatchEvent
       * @private
       * @param  {Object[]} data - Array of operations
       */

      value: function _handlePatchEvent(newValue, oldValue, paths) {
        this._inLayerParser = false;
        if (paths[0].indexOf("recipient_status") === 0) {
          this.__updateRecipientStatus(this.recipientStatus, oldValue);
        }
        this._inLayerParser = true;
      }
    },
    _xhr: {

      /**
       * Any xhr method called on this message uses the message's url.
       *
       * {@link layer.ClientAuthenticator#xhr}
       *
       * @method xhr
       * @protected
       * @return {layer.Message} this
       */

      value: function _xhr(options, callback) {
        // initialize
        var inUrl = options.url;
        var client = this.getClient();
        var conversation = this.getConversation();

        // Validatation
        if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
        if (!("url" in options)) throw new Error(LayerError.dictionary.urlRequired);
        if (!conversation) throw new Error(LayerError.dictionary.conversationMissing);

        if (inUrl && !inUrl.match(/^(\/|\?)/)) options.url = inUrl = "/" + options.url;

        // Setup sync structure
        options.sync = this._setupSyncObject(options.sync);

        // Setup the url in case its not yet known
        var getUrl = (function getUrl() {
          return this.url + (inUrl || "");
        }).bind(this);

        if (this.url) {
          options.url = getUrl();
        } else {
          options.url = getUrl;
        }

        client.xhr(options, callback);
        return this;
      }
    },
    _setupSyncObject: {
      value: function _setupSyncObject(sync) {
        if (sync !== false) {
          if (!sync) sync = {};
          if (!sync.target) sync.target = this.id;
          if (!sync.depends) {
            sync.depends = [this.conversationId];
          } else if (sync.depends.indexOf(this.id) === -1) {
            sync.depends.push(this.conversationId);
          }
        }
        return sync;
      }
    },
    getText: {

      /**
       * Get all text parts of the Message.
       *
       * Utility method for extracting all of the text/plain parts
       * and concatenating all of their bodys together into a single string.
       *
       * @method getText
       * @param {string} [joinStr='.  '] If multiple message parts of type text/plain, how do you want them joined together?
       * @return {string}
       */

      value: function getText() {
        var joinStr = arguments[0] === undefined ? ". " : arguments[0];

        var textArray = this.parts.map(function (part) {
          if (part.mimeType === "text/plain") {
            return part.body;
          }
        });
        textArray = textArray.filter(function (data) {
          return data;
        });
        return textArray.join(joinStr);
      }
    },
    getImageURLs: {

      /**
       * Utility method extracts an array of image urls that can be put into `img` tags
       *
       * TODO: Not sure how valid/useful this is
       *
       * @method getImageUrls
       * @return {string[]} Array of urls
       */

      value: function getImageURLs() {
        return this.parts.filter(function (part) {
          return Message.imageTypes.indexOf(part.mimeType) !== -1;
        }).map(function (part) {
          return part.getURL();
        });
      }
    },
    toObject: {

      /**
       * Returns a plain object.
       *
       * Object will have all the same public properties as this
       * Message instance.  New object is returned any time
       * any of this object's properties change.
       *
       * @method toObject
       * @return {Object} POJO version of this.
       */

      value: function toObject() {
        if (!this._toObject) {
          this._toObject = _get(Object.getPrototypeOf(Message.prototype), "toObject", this).call(this);
          this._toObject.recipientStatus = Util.clone(this.recipientStatus);
        }
        return this._toObject;
      }
    },
    _clearObject: {

      /**
       * Any time a change event is fired, we clear out appropriate immutable
       * objects.
       *
       * @method _clearObject
       * @private
       */

      value: function _clearObject() {
        this._toObject = null;
      }
    },
    _triggerAsync: {
      value: function _triggerAsync(evtName, args) {
        this._clearObject();
        _get(Object.getPrototypeOf(Message.prototype), "_triggerAsync", this).call(this, evtName, args);
      }
    },
    trigger: {
      value: function trigger(evtName, args) {
        this._clearObject();
        _get(Object.getPrototypeOf(Message.prototype), "trigger", this).call(this, evtName, args);
      }
    }
  }, {
    _createFromServer: {

      /**
       * Creates a message from the server's representation of a message.
       * Similar to _populateFromServer, however, this method takes a
       * message description and returns a message instance using _populateFromServer
       * to setup the values.
       *
       * @method _createFromServer
       * @protected
       * @static
       * @param  {Object} m - Server's representation of the message
       * @param  {layer.Conversation} c - Conversation for the message
       * @return {layer.Message}
       */

      value: function _createFromServer(messageIn, conversation) {
        if (!(conversation instanceof Root)) throw new Error(LayerError.dictionary.conversationMissing);

        var client = conversation.getClient();
        var found = client.getMessage(messageIn.id);
        var message = undefined;
        if (found) {
          message = found;
          message._populateFromServer(messageIn);
        } else {
          var fromWebsocket = messageIn.fromWebsocket;
          message = new Message({
            fromServer: messageIn,
            conversationId: conversation.id,
            clientId: client.appId,
            _notify: fromWebsocket && messageIn.is_unread && messageIn.sender.user_id !== client.userId });
        }

        var status = message.recipientStatus[client.userId];
        if (status !== Constants.RECEIPT_STATE.READ && status !== Constants.RECEIPT_STATE.DELIVERED) message._sendReceipt("delivery");

        return {
          message: message,
          "new": !found };
      }
    },
    load: {

      /**
       * Loads the specified message from the server.
       *
       * @method load
       * @static
       * @param  {string} id - Message identifier
       * @param  {layer.Client} client - Client whose conversations should contain the new message
       * @return {layer.Message}
       */

      value: function load(id, client) {
        var _this = this;

        if (!client || !(client instanceof Root)) throw new Error(LayerError.dictionary.clientMissing);
        if (id.indexOf("layer:///messages/") !== 0) throw new Error(LayerError.dictionary.invalidId);

        var message = new Message({
          id: id,
          url: client.url + id.substring(8),
          clientId: client.appId });
        message.syncState = Constants.SYNC_STATE.LOADING;
        client.xhr({
          url: message.url,
          method: "GET",
          sync: false }, function (result) {
          return _this._loadResult(message, client, result);
        });
        return message;
      }
    },
    _loadResult: {
      value: function _loadResult(message, client, result) {
        if (!result.success) {
          message.syncState = Constants.SYNC_STATE.NEW;
          message._triggerAsync("messages:loaded-error", { error: result.data });
        } else {
          this._loadSuccess(message, client, result.data);
        }
      }
    },
    _loadSuccess: {
      value: function _loadSuccess(message, client, response) {
        message._populateFromServer(response);
        message.conversationId = response.conversation.id;
        message._triggerAsync("messages:loaded");
      }
    },
    _loadResourceForPatch: {

      /**
       * At this time there are no properties that are patched on Messages via websockets
       * that would justify loading the Message from the server so as to notify the app.
       * Only recipient status changes and maybe is_unread changes are sent;
       * neither of which are relevant to an app that isn't rendering that message.
       *
       * @method _loadResourceForPatch
       * @static
       * @private
       */

      value: function _loadResourceForPatch(patchData) {
        return false;
      }
    }
  });

  return Message;
})(Syncable);

/**
 * Client that the conversation belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 */
Message.prototype.clientId = "";

/**
 * Conversation that this Message belongs to.
 *
 * Actual value is the ID of the Conversation.
 *
 * @type {string}
 */
Message.prototype.conversationId = "";

/**
 * Array of layer.MessagePart objects
 *
 * @type {layer.MessagePart[]}
 */
Message.prototype.parts = null;

/**
 * Message Identifier
 * @type {String}
 */
Message.prototype.id = "";

/**
 * URL to the server endpoint for operating on the message
 * @type {String}
 */
Message.prototype.url = "";

/**
 * Time that the message was sent
 * @type {Date}
 */
Message.prototype.sentAt = null;

/**
 * Time that the first delivery receipt was sent by your
 * user acknowledging receipt of the message.
 * @type {Date}
 */
Message.prototype.receivedAt = null;

/**
 * Who sent the Message.  Contains `userId` property which is
 * populated when the message was sent by a participant (or former participant)
 * in the Conversation.  Contains a `name` property which is
 * used when the Message is sent via a Named Platform API sender
 * such as "Admin", "Moderator", "Robot Jerking you Around".
 *
 *      <span class='sent-by'>
 *        {message.sender.name || getUsernameForId(message.sender.userId)}
 *      </span>
 *
 * @type {Object}
 */
Message.prototype.sender = null;

/**
 * Position of this message within the conversation.
 *
 * NOTES:
 *
 * 1. Deleting a message does not affect position
 * 2. A position is not gaurenteed to be unique (multiple messages sent at the same time could
 * all claim the same position)
 * 3. Each successive message within a conversation should expect a higher position.
 *
 * @type {Number}
 */
Message.prototype.position = 0;

/**
 * Hint used by layer.Client on whether to trigger a messages:notify event
 *
 * @type {boolean}
 * @private
 */
Message.prototype._notify = false;

/* Recipient Status */

/**
 * Read/delivery State of all participants.
 *
 * This is an object containing keys for each participant,
 * and a value of 'sent', 'delivered' or 'read'
 *
 * @type {Object}
 */
Message.prototype.recipientStatus = null;

/**
 * True if this Message has been read by this user.
 *
 * You can change isRead programatically
 *
 *      m.isRead = true;
 *
 * This will automatically notify the server that the message was read by your user.
 * @type {Boolean}
 */
Message.prototype.isRead = false;

/**
 * This property is here for convenience only; it will always be the opposite of isRead.
 * @type {Boolean}
 * @readonly
 */
Object.defineProperty(Message.prototype, "isUnread", {
  enumerable: true,
  get: function get() {
    return !this.isRead;
  } });

/**
 * Have the other participants read this Message yet.
 *
 * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 * @type {String}
 */
Message.prototype.readStatus = Constants.RECIPIENT_STATE.NONE;

/**
 * Have the other participants received this Message yet.
 *
  * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 *
 * @type {String}
 */
Message.prototype.deliveryStatus = Constants.RECIPIENT_STATE.NONE;

/**
 * The time that this client created this instance.
 * @type {Date}
 */
Message.prototype.localCreatedAt = null;

/**
 * Shortcut to determining if the Message is currently being sent, and therefore
 * has not yet been received by the server.
 *
 * NOTE: There is a special case where isSending is true and syncState !== layer.Constants.SYNC_STATE.SAVING,
 * which occurs after `send()` has been called, but while waiting for Rich Content to upload prior to actually
 * sending this to the server.
 *
 * @type {Boolean}
 */
Message.prototype.isSending = false;

Message.prototype._toObject = null;

Message.prefixUUID = "layer:///messages/";

Message.inObjectIgnore = Syncable.inObjectIgnore;

Message.bubbleEventParent = "getClient";

Message.imageTypes = ["image/gif", "image/png", "image/jpeg", "image/jpg"];

Message._supportedEvents = [

/**
 * Message has been loaded from the server.
 *
 * Note that this is only used in response to the load() method.
 * @event
 */
"messages:loaded",

/**
 * The load method failed to load the message from the server.
 *
 * @event
 */
"messages:loaded-error",

/**
 * Message deleted from the server.
 *
 * Caused by a call to delete() or a websocket event.
 * @event
 */
"messages:delete",

/**
 * Message is about to be sent.
 *
 * Last chance to modify the message prior to sending.
 * @event
 */
"messages:sending",

/**
 * Message has been received by the server.
 *
 * It does NOT indicate delivery to other users.
 *
 * It does NOT indicate messages sent by other users.
 *
 * @event
 * @param {layer.Message} message
 */
"messages:sent",

/**
 * Server failed to receive the Message.
 *
 * @event
 * @param {layer.LayerError} error
 */
"messages:sent-error",

/**
 * Fired when message.isRead is set to true.
 *
 * As this will often be done
 * by the app (rather than the layer framework), you may want to ignore this.
 * Useful if you style unread messages in bold, and need an event to tell you when
 * to unbold the message.
 * @event
 * @param {layer.Message[]} messages - Array of messages that have just been marked as read
 */
"messages:read",

/**
 * The recipientStatus property has changed.
 *
 * This happens in response to an update
 * from the server... but may be caused marking the current user has having read
 * or received the message.
 * @event
 */
"messages:change"].concat(Syncable._supportedEvents);

Root.initClass.apply(Message, [Message, "Message"]);
module.exports = Message;

// Do nothing