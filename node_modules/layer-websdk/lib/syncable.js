"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/**
 * Represents resources that are syncable with the server; represents the state of the object's sync.
 *
 * @class layer.Syncable
 * @extends layer.Root
 */

var Root = require("./root");
var Constants = require("./const");

var Syncable = (function (_Root) {
  function Syncable() {
    _classCallCheck(this, Syncable);

    if (_Root != null) {
      _Root.apply(this, arguments);
    }
  }

  _inherits(Syncable, _Root);

  _createClass(Syncable, {
    _setSyncing: {

      /**
       * Object is queued for syncing with the server.
       *
       * That means it is currently out of sync with the server.
       *
       * @method _setSyncing
       * @private
       */

      value: function _setSyncing() {
        switch (this.syncState) {
          case Constants.SYNC_STATE.SYNCED:
            this.syncState = Constants.SYNC_STATE.SYNCING;
            break;
          case Constants.SYNC_STATE.NEW:
            this.syncState = Constants.SYNC_STATE.SAVING;
            break;
        }
        this._syncCounter++;
      }
    },
    _setSynced: {

      /**
       * Object is synced with the server and up to date.
       *
       * @method _setSynced
       * @private
       */

      value: function _setSynced() {
        if (this._syncCounter > 0) this._syncCounter--;

        this.syncState = this._syncCounter === 0 ? Constants.SYNC_STATE.SYNCED : Constants.SYNC_STATE.SYNCING;
        this.isSending = false;
      }
    }
  });

  return Syncable;
})(Root);

/**
 * The current sync state of this object.
 *
 * Possible values are:
 *
 *  * layer.Constants.SYNC_STATE.NEW: Newly created; local only.
 *  * layer.Constants.SYNC_STATE.SAVING: Newly created; being sent to the server
 *  * layer.Constants.SYNC_STATE.SYNCING: Exists on both client and server, but changes are being sent to server.
 *  * layer.Constants.SYNC_STATE.SYNCED: Exists on both client and server and is synced.
 *  * layer.Constants.SYNC_STATE.LOADING: Exists on server; loading it into client.
 *
 * NOTE: There is a special case where isSending is true and syncState !== layer.Constants.SYNC_STATE.SAVING,
 * which occurs after `send()` has been called, but while waiting for Rich Content to upload prior to actually
 * sending this to the server.
 *
 * @type {string}
 */
Syncable.prototype.syncState = Constants.SYNC_STATE.NEW;

/**
 * Number of sync requests that have been requested.
 *
 * Counts down to zero; once it reaches zero, all sync
 * requests have been completed.
 *
 * @type {Number}
 * @private
 */
Syncable.prototype._syncCounter = 0;

/**
 * Is the object loading from the server?
 *
 * @type {boolean}
 */
Object.defineProperty(Syncable.prototype, "isLoading", {
  enumerable: true,
  get: function get() {
    return this.syncState === Constants.SYNC_STATE.LOADING;
  } });

Syncable._supportedEvents = [].concat(Root._supportedEvents);
Syncable.inObjectIgnore = Root.inObjectIgnore;
module.exports = Syncable;