"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/**
 * Layer Client.  Access the layer by calling create and receiving it
 * from the "ready" callback.

  var client = new layer.Client({
    appId: "layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff",
    userId: "Dref",
    challenge: function(evt) {
      myAuthenticator({
        nonce: evt.nonce,
        onSuccess: evt.callback
      });
    },
    ready: function(client) {
      alert("Yay, I finally got my client!");
    }
  });

 * The Layer Client/ClientAuthenticator classes have been divided into:
 *
 * 1. ClientAuthenticator: Manages all authentication and connectivity related issues
 * 2. Client: Manages access to Conversations, Queries, Messages, Events, etc...
 *
 * @class layer.ClientAuthenticator
 * @private
 * @extends layer.Root
 * @author Michael Kantor
 *
 */

var xhr = require("./xhr");
var Root = require("./root");
var WebsocketManager = require("./websocket-manager");
var LayerError = require("./layer-error");
var OnlineManager = require("./online-state-manager");
var SyncManager = require("./sync-manager");

var _require = require("./sync-event");

var XHRSyncEvent = _require.XHRSyncEvent;
var WebsocketSyncEvent = _require.WebsocketSyncEvent;

var _require2 = require("./const");

var ACCEPT = _require2.ACCEPT;
var LOCALSTORAGE_KEYS = _require2.LOCALSTORAGE_KEYS;
var LOG = _require2.LOG;

var atob = typeof window === "undefined" ? require("atob") : window.atob;
var logger = require("./logger");

var MAX_XHR_RETRIES = 3;

var Client = (function (_Root) {

  /**
   * Create a new Client.
   *
   * While the appId is the only required parameter, the userId parameter
   * is strongly recommended.
   *
   *      var client = new Client({
   *          appId: "layer:///apps/staging/uuid",
   *          userId: "fred"
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param  {string} options.appId           - "layer:///apps/production/uuid"; Identifies what
   *                                            application we are connecting to.
   * @param  {string} [options.url=https://api.layer.com] - URL to log into a different REST server
   * @param  {string} [options.userId='']       - If you provide a userId, we will
   *                                            compare the userId against the one in localStorage
   *                                            to validate use of the cached sessionToken.  This is
   *                                            useful for insuring a change in users in your app
   *                                            gets a change in Layer Sessions.  Failure to provide this
   *                                            parameter means that we will NOT restore the session token.
   * @param {number} [options.logLevel=ERROR] - Provide a log level that is one of layer.Constants.LOG.NONE, layer.Constants.LOG.ERROR,
   *                                            layer.Constants.LOG.WARN, layer.Constants.LOG.INFO, layer.Constants.LOG.DEBUG
   */

  function Client(options) {
    _classCallCheck(this, Client);

    // Validate required parameters
    if (!options.appId) throw new Error(LayerError.dictionary.appIdMissing);

    // We won't copy in userId; thats set from the identity-token... or from cache.
    // the userId argument is a way to identify if there has been a change of users.
    var requestedUserId = options.userId;
    var cachedSessionData = global.localStorage ? global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + options.appId] : null;
    var cachedUserId = "";
    try {
      cachedUserId = cachedSessionData ? JSON.parse(cachedSessionData).userId : "";
    } catch (error) {}

    delete options.userId;

    _get(Object.getPrototypeOf(Client.prototype), "constructor", this).call(this, options);

    this.url = this.url.replace(/\/$/, "");

    // If we've been provided with a user id as a parameter, attempt to restore the session.
    if (requestedUserId) {
      this._restoreLastSession(options, requestedUserId, cachedUserId);
    }
  }

  _inherits(Client, _Root);

  _createClass(Client, {
    _restoreLastSession: {

      /**
       * Handles cases where constructor is given a userId OR a userID + sessionToken.
       *
       * @method _restoreLastSession
       * @private
       */

      value: function _restoreLastSession(options, requestedUserId, cachedUserId) {
        var sessionToken = options.sessionToken || this._getSessionToken();
        if (options.sessionToken) {
          this.userId = requestedUserId;
        } else if (sessionToken && cachedUserId === requestedUserId) {
          this.sessionToken = sessionToken;
          this.userId = requestedUserId;
        } else {
          this.sessionToken = "";
          this.userId = "";
        }
      }
    },
    _initComponents: {

      /**
       * Initialize the subcomponents of the ClientAuthenticator
       *
       * @method _initComponents
       * @private
       */

      value: function _initComponents() {
        // Setup the websocket manager; won't connect until we trigger an authenticated event
        this.socketManager = new WebsocketManager({
          client: this });

        this.onlineManager = new OnlineManager({
          websocketManager: this.socketManager,
          testUrl: this.url + "/nonces?connection-test",
          connected: this._handleOnlineChange.bind(this),
          disconnected: this._handleOnlineChange.bind(this) });

        this.syncManager = new SyncManager({
          onlineManager: this.onlineManager,
          websocketManager: this.socketManager,
          client: this });

        this._connect();
      }
    },
    _destroyComponents: {

      /**
       * Destroy the subcomponents of the ClientAuthenticator
       *
       * @method _destroyComponents
       * @private
       */

      value: function _destroyComponents() {
        this.syncManager.destroy();
        this.onlineManager.destroy();
        this.socketManager.destroy();
      }
    },
    _getSessionToken: {
      /**
       * Gets/restores the sessionToken
       *
       * @private
       * @method _getSessionToken
       * @return {string}
       */

      value: function _getSessionToken() {
        if (this.sessionToken) {
          return this.sessionToken;
        }var cachedSessionData = global.localStorage ? global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId] : "{}";
        try {
          return JSON.parse(cachedSessionData).sessionToken;
        } catch (error) {
          return "";
        }
      }
    },
    _connect: {

      /* CONNECT METHODS BEGIN */

      /**
       * Initiates the connection.
       *
       * Called by constructor().
       *
       * Will either attempt to validate the cached sessionToken by getting converations,
       * or if no sessionToken, will call /nonces to start process of getting a new one.
       *
       * @private
       * @method _connect
       *
       * TODO: Need to be able to configure what the test request is.  A Query? A Message?  Should
       * not be hardcoded to create a Conversation
       */

      value: function _connect() {
        var _this = this;

        if (this.sessionToken) {
          // This will return an error with a nonce if the token is not valid.
          this.xhr({
            url: "/messages/ffffffff-ffff-ffff-ffff-ffffffffffff",
            method: "GET",
            sync: false,
            headers: {
              "content-type": "application/json" } }, function (result) {
            return _this._connectionWithSessionResponse(result);
          });
        } else {
          this.xhr({
            url: "/nonces",
            method: "POST",
            sync: false }, function (result) {
            return _this._connectionResponse(result);
          });
        }
      }
    },
    _connectionWithSessionResponse: {

      /**
       * Called when our test of our last sessionToken gets a response.
       *
       * If the response is an error, call _sessionTokenExpired with the new nonce
       * returned in the error.
       *
       * If the response is successful, then, well, we have Conversations, and can call _sessionTokenRestored
       * with those Conversations.
       *
       * @private
       * @method _connectionWithSessionResponse
       * @param  {Object} result
       */

      value: function _connectionWithSessionResponse(result) {
        if (!result.success && result.data.getNonce()) {
          this._sessionTokenExpired(result.data.getNonce());
        } else {
          this._sessionTokenRestored(result.data);
        }
      }
    },
    _connectionResponse: {

      /**
       * Called when our request for a nonce gets a response.
       *
       * If there is an error, calls _connectionError.
       *
       * If there is nonce, calls _connectionComplete.
       *
       * @method _connectionResponse
       * @private
       * @param  {Object} result
       */

      value: function _connectionResponse(result) {
        if (!result.success) {
          this._connectionError(result.data);
        } else {
          this._connectionComplete(result.data);
        }
      }
    },
    _connectionComplete: {

      /**
       * We are now connected (we have a nonce).
       *
       * If we have successfully retrieved a nonce, then
       * we have entered a "connected" but not "authenticated" state.
       * Set the state, trigger any events, and then start authentication.
       *
       * @method _connectionComplete
       * @private
       * @param  {Object} result
       * @param  {string} result.nonce - The nonce provided by the server
       *
       * @fires connected
       */

      value: function _connectionComplete(result) {
        this.isConnected = true;
        this.trigger("connected");
        this._authenticate(result.nonce);
      }
    },
    _connectionError: {

      /**
       * Called when we fail to get a nonce.
       *
       * @method _connectionError
       * @private
       * @param  {layer.LayerError} err
       *
       * @fires connected-error
       */

      value: function _connectionError(error) {
        this.trigger("connected-error", { error: error });
      }
    },
    _authenticate: {

      /* CONNECT METHODS END */

      /* AUTHENTICATE METHODS BEGIN */

      /**
       * Start the authentication step.
       *
       * We start authentication by triggering a "challenge" event that
       * tells the app to use the nonce to obtain an identity_token.
       *
       * @method _authenticate
       * @private
       * @param  {string} nonce - The nonce to provide your identity provider service
       *
       * @fires challenge
       */

      value: function _authenticate(nonce) {
        if (nonce) {
          this.trigger("challenge", {
            nonce: nonce,
            callback: this.answerAuthenticationChallenge.bind(this) });
        }
      }
    },
    answerAuthenticationChallenge: {

      /**
       * Accept an identityToken and use it to create a session.
       *
       * Typically, this method is called using the function pointer provided by
       * the challenge event, but it can also be called directly.
       *
       *      getIdentityToken(nonce, function(identityToken) {
       *          client.answerAuthenticationChallenge(identityToken);
       *      });
       *
       * @method answerAuthenticationChallenge
       * @param  {string} identityToken - Identity token provided by your identity provider service
       */

      value: function answerAuthenticationChallenge(identityToken) {
        var _this = this;

        // Report an error if no identityToken provided
        if (!identityToken) {
          throw new Error(LayerError.dictionary.identityTokenMissing);
        } else {
          // Store the UserId and get a sessionToken; bypass the __adjustUserId connected test
          this.__userId = JSON.parse(atob(identityToken.split(".")[1])).prn;
          this.xhr({
            url: "/sessions",
            method: "POST",
            sync: false,
            data: {
              identity_token: identityToken,
              app_id: this.appId } }, function (result) {
            return _this._authResponse(result, identityToken);
          });
        }
      }
    },
    _authResponse: {

      /**
       * Called when our request for a sessionToken receives a response.
       *
       * @private
       * @method _authResponse
       * @param  {Object} result
       * @param  {string} identityToken
       */

      value: function _authResponse(result, identityToken) {
        if (!result.success) {
          this._authError(result.data, identityToken);
        } else {
          this._authComplete(result.data);
        }
      }
    },
    _authComplete: {

      /**
       * Authentication is completed, update state and trigger events.
       *
       * @method _authComplete
       * @private
       * @param  {Object} result
       * @param  {string} result.session_token - Session token received from the server
       *
       * @fires authenticated
       */

      value: function _authComplete(result) {
        if (!result || !result.session_token) {
          throw new Error(LayerError.dictionary.sessionTokenMissing);
        }
        this.sessionToken = result.session_token;

        // NOTE: We store both items of data in a single key because someone listening for storage
        // events is listening for an asynchronous change, and we need to gaurentee that both
        // userId and session are available.
        if (global.localStorage) {
          global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId] = JSON.stringify({
            sessionToken: this.sessionToken || "",
            userId: this.userId || "" });
        }

        this.isAuthenticated = true;
        this.trigger("authenticated");
        this._clientReady();
      }
    },
    _authError: {

      /**
       * Authentication has failed.
       *
       * @method _authError
       * @private
       * @param  {layer.LayerError} result
       * @param  {string} identityToken Not currently used
       *
       * @fires authenticated-error
       */

      value: function _authError(error, identityToken) {
        this.trigger("authenticated-error", { error: error });
      }
    },
    _sessionTokenRestored: {

      /**
       * Sets state and triggers events for both connected and authenticated.
       *
       * If reusing a sessionToken cached in localStorage,
       * use this method rather than _authComplete.
       *
       * @method _sessionTokenRestored
       * @private
       *
       * @fires connected, authenticated
       */

      value: function _sessionTokenRestored(result) {
        this.isConnected = true;
        this.trigger("connected");
        this.isAuthenticated = true;
        this.trigger("authenticated");
        this._clientReady();
      }
    },
    _sessionTokenExpired: {

      /**
       * Tried to reuse a cached sessionToken but was rejected.
       *
       * On failing to restore a sessionToken stored in localStorage,
       * Start the connect() process anew.
       *
       * @method _sessionTokenExpired
       * @private
       */

      value: function _sessionTokenExpired(nonce) {
        this.sessionToken = "";
        if (global.localStorage) {
          localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
        }
        this._authenticate(nonce);
      }
    },
    _clientReady: {

      /**
       * Called to flag the client as ready for action.
       *
       * This method is called after authenication AND
       * after initial conversations have been loaded.
       *
       * @method _clientReady
       * @private
       * @fires ready
       */

      value: function _clientReady() {
        if (!this.isReady) {
          this.isReady = true;
          this.trigger("ready");
          this.onlineManager.start();
        }
      }
    },
    logout: {

      /* CONNECT METHODS END */

      /* START SESSION MANAGEMENT METHODS */

      /**
       * Deletes your sessionToken from the server, and removes all user data from the Client.
       * Call `client.login()` to restart the authentication process.
       *
       * @method logout
       * @return {layer.Client} this
       */

      value: function logout() {
        if (this.isAuthenticated) {
          this.xhr({
            method: "DELETE",
            url: "/sessions/" + escape(this.sessionToken) });
        }

        // Clear data even if isAuthenticated is false
        // Session may have expired, but data still cached.
        this._resetSession();
        return this;
      }
    },
    login: {

      /**
       * This method is not needed under normal conditions.
       * However, if after calling `logout()` you want to
       * get a new nonce and trigger a new `challenge` event,
       * call `login()`.
       *
       * @method login
       * @return {layer.Client} this
       */

      value: function login() {
        this._connect();
        return this;
      }
    },
    _resetSession: {

      /**
       * Log out/clear session information.
       *
       * Use this to clear the sessionToken and all information from this session.
       *
       * @method _resetSession
       * @private
       * @returns {layer.Client} this
       */

      value: function _resetSession() {
        this.isReady = false;
        if (this.sessionToken) {
          this.sessionToken = "";
          if (global.localStorage) {
            localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
          }
        }
        this.isConnected = false;
        this.isAuthenticated = false;

        this.trigger("deauthenticated");
        this.onlineManager.stop();
      }
    },
    __adjustAppId: {

      /* SESSION MANAGEMENT METHODS END */

      /* ACCESSOR METHODS BEGIN */

      /**
       * __ Methods are automatically called by property setters.
       * Any attempt to execute `this.userAppId = 'xxx'` will cause an error to be thrown
       * if the client is already connected.
       *
       * @private
       * @method __adjustAppId
       * @param {string} value - New appId value
       */

      value: function __adjustAppId(value) {
        if (this.isConnected) throw new Error(LayerError.dictionary.cantChangeIfConnected);
      }
    },
    __adjustUserId: {

      /**
       * __ Methods are automatically called by property setters.
       * Any attempt to execute `this.userId = 'xxx'` will cause an error to be thrown
       * if the client is already connected.
       *
       * @private
       * @method __adjustUserId
       * @param {string} value - New appId value
       */

      value: function __adjustUserId(value) {
        if (this.isConnected) throw new Error(LayerError.dictionary.cantChangeIfConnected);
      }
    },
    sendSocketRequest: {

      /* ACCESSOR METHODS END */

      /* COMMUNICATIONS METHODS BEGIN */

      value: function sendSocketRequest(params, callback) {
        if (params.sync) {
          var target = params.sync.target;
          var depends = params.sync.depends;
          if (target && !depends) depends = [target];

          this.syncManager.request(new WebsocketSyncEvent({
            data: params.body,
            operation: params.method,
            target: target,
            depends: depends,
            callback: callback }));
        } else {
          if (typeof params.data === "function") params.data = params.data();
          this.socketManager.sendRequest(params, callback);
        }
      }
    },
    _handleOnlineChange: {

      /**
       * This event handler receives events from the Online State Manager and generates an event for those subscribed
       * to client.on('online')
       *
       * @method _handleOnlineChange
       * @private
       * @param {layer.LayerEvent} evt
       */

      value: function _handleOnlineChange(evt) {
        if (!this.isAuthenticated) {
          return;
        }var duration = evt.offlineDuration;
        var isOnline = evt.eventName === "connected";
        var obj = { isOnline: isOnline };
        if (isOnline) {
          obj.reset = duration > Client.ResetAfterOfflineDuration;
        }
        this.trigger("online", obj);
      }
    },
    xhr: {

      /**
       * Main entry point for sending xhr requests or for queing them in the syncManager.
       *
       * This call adjust arguments for our REST server.
       *
       * @method xhr
       * @protected
       * @param  {Object}   options
       * @param  {string}   options.url - URL relative client's url: "/conversations"
       * @param  {Function} callback
       * @param  {Object}   callback.result
       * @param  {Mixed}    callback.result.data - If an error occurred, this is a layer.LayerError;
       *                                          If the response was application/json, this will be an object
       *                                          If the response was text/empty, this will be text/empty
       * @param  {XMLHttpRequest} callback.result.xhr - Native xhr request object for detailed analysis
       * @param  {Object}         callback.result.Links - Hash of Link headers
       * @return {layer.ClientAuthenticator} this
       */

      value: function xhr(options, callback) {
        if (typeof options.url === "string") {
          options.url = this._xhrFixRelativeUrls(options.url);
        }

        options.withCredentials = true;
        if (!options.method) options.method = "GET";
        if (!options.headers) options.headers = {};
        this._xhrFixHeaders(options.headers);
        this._xhrFixAuth(options.headers);

        // Note: this is not sync vs async; this is syncManager vs fire it now
        if (options.sync === false) {
          this._nonsyncXhr(options, callback, 0);
        } else {
          this._syncXhr(options, callback);
        }
        return this;
      }
    },
    _syncXhr: {
      value: function _syncXhr(options, callback) {
        var _this = this;

        if (!options.sync) options.sync = {};
        var innerCallback = function (result) {
          _this._xhrResult(result, callback);
        };
        var target = options.sync.target;
        var depends = options.sync.depends;
        if (target && !depends) depends = [target];

        this.syncManager.request(new XHRSyncEvent({
          url: options.url,
          data: options.data,
          method: options.method,
          operation: options.sync.operation || options.method,
          headers: options.headers,
          callback: innerCallback,
          target: target,
          depends: depends }));
      }
    },
    _nonsyncXhr: {

      /**
       * For xhr calls that don't go through the sync manager,
       * fire the request, and if it fails, refire it up to 3 tries
       * before reporting an error.  1 second delay between requests
       * so whatever issue is occuring is a tiny bit more likely to resolve,
       * and so we don't hammer the server every time there's a problem.
       *
       * @method _nonsyncXhr
       * @param  {Object}   options
       * @param  {Function} callback
       * @param  {number}   retryCount
       */

      value: function _nonsyncXhr(options, callback, retryCount) {
        var _this = this;

        xhr(options, function (result) {
          if ([502, 503, 504].indexOf(result.status) !== -1 && retryCount < MAX_XHR_RETRIES) {
            setTimeout(function () {
              return _this._nonsyncXhr(options, callback, retryCount + 1);
            }, 1000);
          } else {
            _this._xhrResult(result, callback);
          }
        });
      }
    },
    _xhrFixAuth: {

      /**
       * Fix authentication header for an xhr request
       *
       * @method _xhrFixAuth
       * @private
       * @param  {Object} headers
       */

      value: function _xhrFixAuth(headers) {
        if (this.sessionToken && !headers.Authorization) {
          headers.authorization = "Layer session-token=\"" + this.sessionToken + "\""; // eslint-disable-line
        }
      }
    },
    _xhrFixRelativeUrls: {

      /**
       * Fix relative URLs to create absolute URLs needed for CORS requests.
       *
       * @method
       * @private
       * @param  {string} relative or absolute url
       * @return {string} absolute url
       */

      value: function _xhrFixRelativeUrls(url) {
        var result = url;
        if (url.indexOf("https://") === -1) {
          if (url[0] === "/") {
            result = this.url + url;
          } else {
            result = this.url + "/" + url;
          }
        }
        return result;
      }
    },
    _xhrFixHeaders: {

      /**
       * Fixup all headers in preparation for an xhr call.
       *
       * 1. All headers use lower case names for standard/easy lookup
       * 2. Set the accept header
       * 3. If needed, set the content-type header
       *
       * @method
       * @private
       * @param  {Object} headers
       */

      value: function _xhrFixHeaders(headers) {
        // Replace all headers in arbitrary case with all lower case
        // for easy matching.
        var headerNameList = Object.keys(headers);
        headerNameList.forEach(function (headerName) {
          if (headerName !== headerName.toLowerCase()) {
            headers[headerName.toLowerCase()] = headers[headerName];
            delete headers[headerName];
          }
        });

        if (!headers.accept) headers.accept = ACCEPT;

        if (!headers["content-type"]) headers["content-type"] = "application/json";
      }
    },
    _xhrResult: {

      /**
       * Handle the result of an xhr call
       *
       * @method _xhrResult
       * @private
       * @param  {Object}   result     Standard xhr response object from the xhr lib
       * @param  {Function} [callback] Callback on completion
       */

      value: function _xhrResult(result, callback) {
        if (this.isDestroyed) {
          return;
        }if (!result.success) {
          // Replace the response with a LayerError instance
          if (result.data && typeof result.data === "object") {
            this._generateError(result);
          }

          // If its an authentication error, reauthenticate
          // don't call _resetSession as that wipes all data and screws with UIs, and the user
          // is still authenticated on the customer's app even if not on Layer.
          if (result.status === 401 && this.isAuthenticated) {
            logger.warn("SESSION EXPIRED!");
            this.isAuthenticated = false;
            this.trigger("deauthenticated");
            this._authenticate(result.data.getNonce());
          }
        }
        if (callback) callback(result);
      }
    },
    _generateError: {

      /**
       * Transforms xhr error response into a layer.LayerError instance.
       *
       * Adds additional information to the result object including
       *
       * * url
       * * data
       *
       * @method _generateError
       * @private
       * @param  {Object} result - Result of the xhr call
       */

      value: function _generateError(result) {
        result.data = new LayerError(result.data);
        if (!result.data.httpStatus) result.data.httpStatus = result.status;
        result.data.log();
      }

      /* END COMMUNICATIONS METHODS */

    }
  });

  return Client;
})(Root);

/**
 * State variable; indicates that client is currently authenticated by the server.
 * Should never be true if isConnected is false.
 * @type {Boolean}
 */
Client.prototype.isAuthenticated = false;

/**
 * State variable; indicates that client is currently connected to server
 * (may not be authenticated yet)
 * @type {Boolean}
 */
Client.prototype.isConnected = false;

/**
 * State variable; indicates that client is ready for the app to use.
 * Use the 'ready' event to be notified when this value changes to true.
 *
 * @type {boolean}
 */
Client.prototype.isReady = false;

/**
 * Your Layer Application ID. This value can not be changed once connected.
 * To find your Layer Application ID, see your Layer Developer Dashboard.
 * @type {String}
 */
Client.prototype.appId = "";

/**
 * You can use this to find the userId you are logged in as.
 * You can set this in the constructor to verify that the client
 * will only restore a session if that session belonged to that same userId.
 * @type {String}
 */
Client.prototype.userId = "";

/**
 * Your current session token that authenticates your requests.
 * @type {String}
 */
Client.prototype.sessionToken = "";

/**
 * URL to Layer's Web API server.
 * @type {String}
 */
Client.prototype.url = "https://api.layer.com";

/**
 * Web Socket Manager
 * @type {layer.WebsocketManager}
 */
Client.prototype.socketManager = null;

/**
 * Service for managing online as well as offline server requests
 * @type {layer.SyncManager}
 */
Client.prototype.syncManager = null;

/**
 * Service for managing online/offline state and events
 * @type {layer.OnlineStateManager}
 */
Client.prototype.onlineManager = null;

/**
 * Is true if the client is authenticated and connected to the server;
 *
 * Typically used to determine if there is a connection to the server.
 *
 * Typically used in conjunction with the `online` event.
 *
 * @type {boolean}
 */
Object.defineProperty(Client.prototype, "isOnline", {
  enumerable: true,
  get: function get() {
    return this.onlineManager && this.onlineManager.isOnline;
  } });

/**
 * Log levels; one of:
 *
 *    * layer.Constants.LOG.NONE
 *    * layer.Constants.LOG.ERROR
 *    * layer.Constants.LOG.WARN
 *    * layer.Constants.LOG.INFO
 *    * layer.Constants.LOG.DEBUG
 *
 * @type {number}
 */
Object.defineProperty(Client.prototype, "logLevel", {
  enumerable: false,
  get: function get() {
    return logger.level;
  },
  set: function set(value) {
    logger.level = value;
  } });

/**
 * Time to be offline after which we don't do a WebSocket Events.replay,
 * but instead just refresh all our Query data.  Defaults to 30 hours.
 *
 * @type {number}
 * @static
 */
Client.ResetAfterOfflineDuration = 1000 * 60 * 60 * 30;
/**
 * List of events supported by this class
 * @static
 * @protected
 * @type {string[]}
 */
Client._supportedEvents = [
/**
 * The client is ready for action
 *
 *      client.on('ready', function(evt) {
 *          renderMyUI();
 *      });
 *
 * @event
 */
"ready",

/**
 * Fired when connected to the server.
 * Currently just means we have a nonce.
 * Not recommended for typical applications.
 * @event connected
 */
"connected",

/**
 * Fired when unsuccessful in obtaining a nonce
 * Not recommended for typical applications.
 * @event connected-error
 * @param {Object} event
 * @param {layer.LayerError} event.error
 */
"connected-error",

/**
 * We now have a session and any requests we send aught to work.
 * Typically you should use the ready event instead of the authenticated event.
 * @event authenticated
 */
"authenticated",

/**
 * Failed to authenticate your client.
 *
 * Either your identity-token was invalid, or something went wrong
 * using your identity-token.
 *
 * @event authenticated-error
 * @param {Object} event
 * @param {layer.LayerError} event.error
 */
"authenticated-error",

/**
 * This event fires when a session has expired or when `layer.Client.logout` is called.
 * Typically, it is enough to subscribe to the challenge event
 * which will let you reauthenticate; typical applications do not need
 * to subscribe to this.
 *
 * @event deauthenticated
 */
"deauthenticated",

/**
 * @event challenge
 * Verify the user's identity.
 *
 * This event is where you verify that the user is who we all think the user is,
 * and provide an identity token to validate that.
 *
 * @param {Object} event
 * @param {string} event.nonce - A nonce for you to provide to your identity provider
 * @param {Function} event.callback - Call this once you have an identity-token
 * @param {string} event.callback.identityToken - Identity token provided by your identity provider service
 */
"challenge",

/**
 * @event session-terminated
 * If your session has been terminated in such a way as to prevent automatic reconnect,
 *
 * this event will fire.  Common scenario: user has two tabs open;
 * one tab the user logs out (or you call client.logout()).
 * The other tab will detect that the sessionToken has been removed,
 * and will terminate its session as well.  In this scenario we do not want
 * to automatically trigger a challenge and restart the login process.
 */
"session-terminated",

/**
 * @event online
 *
 * This event is used to detect when the client is online (connected to the server)
 * or offline (still able to accept API calls but no longer able to sync to the server).
 *
 *      client.on('online', function(evt) {
 *         if (evt.isOnline) {
 *             statusDiv.style.backgroundColor = 'green';
 *         } else {
 *             statusDiv.style.backgroundColor = 'red';
 *         }
 *      });
 *
 * @param {Object} event
 * @param {boolean} event.isOnline
 */
"online"].concat(Root._supportedEvents);

Root.initClass.apply(Client, [Client, "Client"]);

module.exports = Client;

// Do nothing